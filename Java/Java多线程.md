## 多线程

### Volatile关键字特性

* 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的（实现可见性）
* 禁止指令重排序（实现有序性）
* volatile只能保证对单次读/写的原子性，i++这种操作不能保证原子性

### Volatile底层

当多个处理器的任务都涉及到同一块主内存区域时，将可能导致各自的缓存数据不一致，为了解决一致性问题，需要各个处理器访问缓存时遵循一些协议

#### Intel的MESI（缓存一致性）协议

当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会内存重新读取

#### 嗅探

每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里

##### 缺点

由于volatile的MESI缓存一致性协议，需要不断的从主内存嗅探和cas不断循环，无效交互会导致总线带宽达到峰值，所以不要大量使用volatile

### JMM（Java内存模型）

所有的共享变量都存储于主内存，每一个线程有自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本

线程对变量的所有的操作（读，取）都必须在工作内存中完成，而不能直接读写主内存中的变量

不同线程之间不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存中转完成

**本地内存和主内存的关系**

![](https://raw.githubusercontent.com/whn961227/images/master/data/20200708161935.png)



### 可见性问题解决方案

* **加锁**

  某一个线程进入synchronized代码块前后，线程会获得锁，清空工作内存，从主内存拷贝共享变量最新的值到工作内存中成为副本，执行代码，将修改后的副本的值刷新回主内存中，线程释放锁

  而获取不到锁的线程会阻塞等待，所以变量的值肯定一直都是最新的

* **Volatile修饰共享变量**

  每个线程操作数据的时候会把数据从主内存读取到自己的工作内存，如果操作了数据并且写回了，其他已经读取的线程的变量副本就失效了



