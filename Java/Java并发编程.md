## 并发编程

### 并行与并发

单核CPU下，线程实际是 **串行执行** 的。任务调度器将CPU的时间片分给不同的线程使用

一般会将这种线程轮流使用CPU的做法称为 **并发**，concurrent

多核CPU下，每个核都可以调度运行线程，这时候线程是 **并行** 的

#### 结论

1. 单核CPU下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用CPU，不至于一个线程总占用CPU，别的线程无法运行
2. 多核CPU可以并行跑多个线程，但能否提高程序运行效率还是要分情况的
   * 有的任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任务都能拆分
   * 也不是所有任务都需要拆分，任务的目的不同，拆分和效率就没什么意义
3. IO操作不占用CPU，只是一般拷贝文件使用的是 **阻塞IO**， 这时相当于线程虽然不用CPU，但需要一直等待IO结束，没能充分利用线程。所以才有 **非阻塞IO** 和 **异步IO** 的优化



### 同步与异步

从方法调用的角度：

* 需要等待结果返回才能继续运行就是 **同步**
* 不需要等待结果返回就能继续运行就是 **异步**



### 创建和运行线程

* **直接使用Thread**

  ```java
  // 创建线程对象
  Thread t = new Thread() {
      public void run() {
          // 要执行的任务
      }
  };
  // 启动线程
  t.start();
  ```

* **使用Runnable配合Thread**

  ```java
  Runnable runnable = new Runnable() {
      public void run(){
          // 要执行的任务
      }
  };
  // 创建线程对象
  Thread t = new Thread(runnable);
  // 启动线程
  t.start();
  ```

* **FutureTask配合Thread**

  ```java
  // 创建任务对象
  FutureTask<Integer> task3 = new FutureTask<>(() -> {
  	log.debug("hello");
      return 100;
  });
  
  // 参数1 是任务对象， 参数2 是线程名字 
  new Thread(task3, "t3").start();
  
  // 主线程阻塞，同步等待 task 执行完毕的结果
  Integer result = task3.get();
  log.debug("结果是：{}", result);
  ```



### 原理之线程运行

#### 栈与栈帧

每个线程启动后，虚拟机就会为其分配一块栈内存

* 每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占的内存
* 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法

#### 线程上下文切换

以下原因导致CPU不再执行当前线程，转而执行另外一个线程：

* 线程的CPU时间片用完
* 垃圾回收
* 有更高优先级的线程需要运行
* 线程自己调用了sleep、yield、wait、join、park、synchronized、lock等方法

当上下文切换发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java中对应的概念就是**程序计数器**，它的作用是记住下一条jvm指令的执行地址，是线程私有的

* 状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等
* 频繁的上下文切换会影响性能了



### Start与Run

```java
public static void main(String[] args) {
    // 创建线程对象
Thread t1 = new Thread("t1") {
    public void run() {
        // 要执行的任务
    }
};
    
t1.run();
}
```

程序仍然在main线程运行



### sleep与yield

#### sleep

1. 调用sleep会让当前线程从Running进入Timed Waiting状态
2. 其他线程可以使用interrupt打断正在睡眠的线程，这时sleep方法会抛出InterruptedException
3. 睡眠结束后的线程未必会立刻得到执行
4. 建议用TimeUnit的sleep代替Thread的sleep来获得更好的可读性

#### yield

1. 调用yield会让当前线程从Running进入Runnable就绪状态，然后调度执行其他线程
2. 具体的实现依赖于操作系统的任务调度器



### 线程优先级

* 线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它
* 如果CPU比较忙，那么优先级高的线程会获得更多的时间片，但CPU闲时，优先级几乎没作用



 ### join方法详解

等待线程运行结束，用于线程同步

```java
static int r = 0;
public static void main(String[] args) throws InterruptedException {
    test1();
}
private static void test1() throws InterruptedException {
    log.debug("开始");
    Thread t1 = new Thread(() -> {
    	log.debug("开始");
        sleep(1);
        log.debug("结束");
        r = 10;
    });
    t1.start();
    // t1.join();
    log.debug("结果为:{}", r);
    log.debug("结束");
}
```

分析

* 因为主线程和t1线程是并行执行的，t1线程需要1s之后才能赋值r=10
* 主线程一开始就打印r的值，所以只能打印出r=0

解决方法

* 用sleep（不知道t1线程执行时间，不推荐）
* 用join，加在t1.start()之后



### Inerrupt方法详解

#### 打断sleep，wait，join的线程

清空打断状态

#### 打断正常运行的线程

不会清空打断状态

#### isInterrupted和interrupted

isInterrupted不会清空打断状态；interrupted清空打断状态



### 主线程与守护线程

默认情况下，Java进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其他非守护线程运行结束了，即时守护线程的代码没有执行完，也会强制结束

> 垃圾回收线程就是守护线程
>
> Tomcat中的Acceptor和Poller线程都是守护线程，所以Tomcat接收到shutdown命令后，不会等待他们处理完当前请求



### 五种状态

* **初始状态**：仅在语言层面创建了线程对象，还未与操作系统线程关联
* **可运行状态**：线程已经被创建（与操作系统线程关联），可以由CPU调度执行
* **运行状态**：获取了CPU时间片，运行时的状态
  * 当CPU时间片用完，会从 **运行状态** 转换至 **可运行状态** ，导致线程上下文切换

* **阻塞状态**： 
  * 如果调用了阻塞API，如BIO读写文件，这时线程实际不会用到CPU，会导致线程上下文切换，进入 **阻塞状态**
  * 等BIO操作完毕，会由操作系统唤醒阻塞的线程，转换至 **可运行状态**
  * 与 **可运行状态** 的区别是，对 **阻塞状态** 的线程来说只要它们一直不唤醒，调度器就不会考虑调度它们

* **终止状态**：表示线程已经执行完毕，生命周期已经结束，不会再转换为其他状态



### 共享带来的问题

#### 临界区

* 一个程序运行多个线程本身是没有问题的
* 问题出在多个线程访问共享资源
  * 多个线程读共享资源其实也没有问题
  * 在多个线程对共享资源**读写**操作时发生指令交错，就会出现问题

* 一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为**临界区**

#### 竞态条件

多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件

#### 互斥解决

为了避免临界区的竞态条件发生，有多种手段可以达到目的

* 阻塞式的解决方案：synchronized，lock
* 非阻塞式的解决方案：原子变量



### synchronized解决方案

synchronized，俗称 **对象锁** ，采用互斥的方式让同一时刻至多只有一个线程能持有 **对象锁** ，其他线程再想获取这个 **对象锁** 时就会被阻塞住。这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换

>虽然java中互斥和同步都可以采用synchronized关键字来完成，但它们还是有区别的：
>
>* 互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码
>* 同步是由于线程执行的先后、顺序不同，需要一个线程等待其他线程运行到某个点

实际是用 **对象锁** 保证了临界区内代码的原子性，临界区内的代码对外是不可分割的，不会被线程切换所打断

* 修饰实例方法，对当前实例对象this加锁
* 修饰静态方法，对当前类的Class对象加锁
* 修饰代码块，指定一个加锁的对象，给对象加锁



### 变量的线程安全分析

#### 成员变量和静态变量是否线程安全

* 如果没有共享，则线程安全
* 如果被共享了，根据它们的状态是否能够改变，又分为两种情况
  * 如果只有读操作，则线程安全
  * 如果有读写操作，则这段代码是临界区，需要考虑线程安全

#### 局部变量是否线程安全

* 局部变量是线程安全的
* 但局部变量引用的对象未必
  * 如果该对象没有逃离方法的作用范围，它是线程安全的
  * 如果该对象逃离方法的作用范围，需要考虑线程安全



### Monitor概念

#### Java对象构成

![image-20200713104455729](https://raw.githubusercontent.com/whn961227/images/master/data/image-20200713104455729.png)

* 对象头
  * Mark Word（标记字段）：默认存储对象的hashcode，分代年龄和锁标志位信息。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化
  * Klass Point（类型指针）：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例
* 实例数据
  * 这部分主要是存放类的数据信息，父类的信息
* 对齐填充
  * 由于虚拟机要求对象起始地址必须是8字节的整数倍，填充数据不是必须存在的，仅仅是为了字节对齐

> 一个空对象占8字节，因为对齐填充的关系，不到8个字节对齐填充会自动补齐

<img src="https://raw.githubusercontent.com/whn961227/images/master/data/20200712221143.png"  />

#### Monitor

* 刚开始Monitor的Owner为null
* 当Thread-2执行synchronized(obj)就会将Monitor的所有者Owner置位Thread-2，Monitor中只能有一个Owner
* 在Thread-2上锁的过程中，如果Thread-3，Thread-4，Thread-5也来执行synchronized(obj)，就会进入EntryList Blocked
* Thread-2执行完同步代码块的内容，然后唤醒EntryList中等待的线程来竞争锁，竞争是非公平的
* WaitSet中的线程是之前获得过锁，但条件不满足进入Waiting状态的线程

> * synchronized必须是进入同一个对象的monitor
> * 不加synchronized的对象不会关联监视器，不遵从以上规则



### Synchronized原理进阶

#### 轻量级锁

如果一个对象虽然有多线程访问，但多线程访问的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化

* 创建锁记录（Lock Record）对象，每个线程对应的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的Mark Word

![](https://raw.githubusercontent.com/whn961227/images/master/data/20200712225008.png)

* 让锁记录中的Object reference指向锁对象，尝试使用cas替换Object的Mark Word，将Mark Word的值存入锁记录

  ![image-20200712225249200](https://raw.githubusercontent.com/whn961227/images/master/data/image-20200712225249200.png)

* 如果cas替换成功，对象头中存储了锁记录地址和状态00，表示由该线程给对象加锁

  ![](https://raw.githubusercontent.com/whn961227/images/master/data/20200712225431.png)

* 如果cas失败，有两种情况
  * 如果是其他线程已经持有了该Object的轻量级锁，这时表明有竞争，进入锁膨胀过程
  * 如果是自己执行了synchronized锁重入，那么再添加一条Lock Record作为重入的计数

![image-20200712225746648](https://raw.githubusercontent.com/whn961227/images/master/data/image-20200712225746648.png)

* 当退出synchronized代码块（解锁时）如果有取值为null的锁记录，表示有重入，这时重置锁记录，表示重入计数减1

![image-20200712225923341](https://raw.githubusercontent.com/whn961227/images/master/data/image-20200712225923341.png)

* 当退出synchronized代码块（解锁时）锁记录的值不为null，这时使用cas将Mark Word的值恢复给对象头
  * 成功，则解锁成功
  * 失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程

#### 锁膨胀

如果在尝试加轻量级锁的过程中，CAS操作无法成功，这时一种情况就是有其他线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁

* 当Thread-1进行轻量级加锁时，Thread-0已经对该对象加了轻量级锁

  <img src="https://raw.githubusercontent.com/whn961227/images/master/data/image-20200713094139464.png" alt="image-20200713094139464" style="zoom: 33%;" />

* 这时Thread-1加轻量级锁失败，进入锁膨胀流程

  * 为Object对象申请Monitor锁，让Object指向重量级锁地址
  * 然后自己进入Monitor的EntryList Blocked

  ![image-20200713094510276](https://raw.githubusercontent.com/whn961227/images/master/data/image-20200713094510276.png)

* 当Thread-0退出同步块解锁时，使用CAS将Mark Word的值恢复给对象头，失败。这时会进入重量级锁解锁流程，即按照Monitor地址找到Monitor对象，设置Owner为null，唤醒EntryList中Blocked线程

#### 自旋优化

重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞

#### 偏向锁

轻量级锁在没有竞争时，每次重入仍然需要执行CAS操作

Java6中引入了偏向锁来做进一步优化：只有第一次使用CAS将线程ID设置到对象的Mark Word头，之后发现这个线程ID是自己的就表示没有竞争，不用重新CAS。

##### 撤销-调用对象hashCode

调用了对象的hashCode，但偏向锁的对象MarkWord中存储的是线程id，如果调用hashCode会导致偏向锁被撤销

* 轻量级锁会在锁记录中记录hashCode
* 重量级锁会在Monitor中记录hashCode

##### 撤销-其他线程使用对象

当有其他线程使用偏向锁对象时，会将偏向锁升级为轻量级锁

##### 撤销-调用wait/notify

##### 批量重定向

如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程T1的对象仍然有机会重新偏向T2，重偏向会重置对象的Thread ID

当撤销偏向锁阈值超过20次后，jvm会给这些对象加锁时重新偏向至加锁线程

##### 批量撤销

当撤销偏向锁阈值超过40次后，整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的

##### 锁消除

### 原理之wait/notify





### Volatile

#### 特性

* 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的（实现可见性）
* 禁止指令重排序（实现有序性）
* volatile只能保证对单次读/写的原子性，i++这种操作不能保证原子性

#### Volatile底层

当多个处理器的任务都涉及到同一块主内存区域时，将可能导致各自的缓存数据不一致，为了解决一致性问题，需要各个处理器访问缓存时遵循一些协议

#### Intel的MESI（缓存一致性）协议

当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会内存重新读取

#### 嗅探

每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里

##### 缺点

由于volatile的MESI缓存一致性协议，需要不断的从主内存嗅探和cas不断循环，无效交互会导致总线带宽达到峰值，所以不要大量使用volatile

### JMM（Java内存模型）

所有的共享变量都存储于主内存，每一个线程有自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本

线程对变量的所有的操作（读，取）都必须在工作内存中完成，而不能直接读写主内存中的变量

不同线程之间不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存中转完成

**本地内存和主内存的关系**

<img src="https://raw.githubusercontent.com/whn961227/images/master/data/20200708161935.png" style="zoom:33%;" />



### 可见性问题解决方案

* **加锁**

  某一个线程进入synchronized代码块前后，线程会获得锁，清空工作内存，从主内存拷贝共享变量最新的值到工作内存中成为副本，执行代码，将修改后的副本的值刷新回主内存中，线程释放锁

  而获取不到锁的线程会阻塞等待，所以变量的值肯定一直都是最新的

* **Volatile修饰共享变量**

  每个线程操作数据的时候会把数据从主内存读取到自己的工作内存，如果操作了数据并且写回了，其他已经读取的线程的变量副本就失效了



