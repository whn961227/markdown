## 并发编程

### 并行与并发

单核CPU下，线程实际是 **串行执行** 的。任务调度器将CPU的时间片分给不同的线程使用

一般会将这种线程轮流使用CPU的做法称为 **并发**，concurrent

多核CPU下，每个核都可以调度运行线程，这时候线程是 **并行** 的

#### 结论

1. 单核CPU下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用CPU，不至于一个线程总占用CPU，别的线程无法运行
2. 多核CPU可以并行跑多个线程，但能否提高程序运行效率还是要分情况的
   * 有的任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任务都能拆分
   * 也不是所有任务都需要拆分，任务的目的不同，拆分和效率就没什么意义
3. IO操作不占用CPU，只是一般拷贝文件使用的是 **阻塞IO**， 这时相当于线程虽然不用CPU，但需要一直等待IO结束，没能充分利用线程。所以才有 **非阻塞IO** 和 **异步IO** 的优化

### 同步与异步

从方法调用的角度：

* 需要等待结果返回才能继续运行就是 **同步**
* 不需要等待结果返回就能继续运行就是 **异步**

### 创建和运行线程

* **直接使用Thread**

  ```java
  // 创建线程对象
  Thread t = new Thread() {
      public void run() {
          // 要执行的任务
      }
  };
  // 启动线程
  t.start();
  ```

* **使用Runnable配合Thread**

  ```java
  Runnable runnable = new Runnable() {
      public void run(){
          // 要执行的任务
      }
  };
  // 创建线程对象
  Thread t = new Thread(runnable);
  // 启动线程
  t.start();
  ```

* **FutureTask配合Thread**

  ```java
  // 创建任务对象
  FutureTask<Integer> task3 = new FutureTask<>(() -> {
  	log.debug("hello");
      return 100;
  });
  
  // 参数1 是任务对象， 参数2 是线程名字 
  new Thread(task3, "t3").start();
  
  // 主线程阻塞，同步等待 task 执行完毕的结果
  Integer result = task3.get();
  log.debug("结果是：{}", result);
  ```

### 原理之线程运行

#### 栈与栈帧

每个线程启动后，虚拟机就会为其分配一块栈内存

* 每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占的内存
* 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法

#### 线程上下文切换

以下原因导致CPU不再执行当前线程，转而执行另外一个线程：

* 线程的CPU时间片用完
* 垃圾回收
* 有更高优先级的线程需要运行
* 线程自己调用了sleep、yield、wait、join、park、synchronized、lock等方法

当上下文切换发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java中对应的概念就是**程序计数器**，它的作用是记住下一条jvm指令的执行地址，是线程私有的

* 状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等
* 频繁的上下文切换会影响性能了

### Start与Run

```java
public static void main(String[] args) {
    // 创建线程对象
Thread t1 = new Thread("t1") {
    public void run() {
        // 要执行的任务
    }
};
    
t1.run();
}
```

程序仍然在main线程运行

### sleep与yield

#### sleep

1. 调用sleep会让当前线程从Running进入Timed Waiting状态
2. 其他线程可以使用interrupt打断正在睡眠的线程，这时sleep方法会抛出InterruptedException
3. 睡眠结束后的线程未必会立刻得到执行
4. 建议用TimeUnit的sleep代替Thread的sleep来获得更好的可读性

### Volatile

#### 特性

* 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的（实现可见性）
* 禁止指令重排序（实现有序性）
* volatile只能保证对单次读/写的原子性，i++这种操作不能保证原子性

#### Volatile底层

当多个处理器的任务都涉及到同一块主内存区域时，将可能导致各自的缓存数据不一致，为了解决一致性问题，需要各个处理器访问缓存时遵循一些协议

#### Intel的MESI（缓存一致性）协议

当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会内存重新读取

#### 嗅探

每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里

##### 缺点

由于volatile的MESI缓存一致性协议，需要不断的从主内存嗅探和cas不断循环，无效交互会导致总线带宽达到峰值，所以不要大量使用volatile

### JMM（Java内存模型）

所有的共享变量都存储于主内存，每一个线程有自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本

线程对变量的所有的操作（读，取）都必须在工作内存中完成，而不能直接读写主内存中的变量

不同线程之间不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存中转完成

**本地内存和主内存的关系**

![](https://raw.githubusercontent.com/whn961227/images/master/data/20200708161935.png)



### 可见性问题解决方案

* **加锁**

  某一个线程进入synchronized代码块前后，线程会获得锁，清空工作内存，从主内存拷贝共享变量最新的值到工作内存中成为副本，执行代码，将修改后的副本的值刷新回主内存中，线程释放锁

  而获取不到锁的线程会阻塞等待，所以变量的值肯定一直都是最新的

* **Volatile修饰共享变量**

  每个线程操作数据的时候会把数据从主内存读取到自己的工作内存，如果操作了数据并且写回了，其他已经读取的线程的变量副本就失效了



