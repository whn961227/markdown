## 基础

### Java 基本功

#### JVM、JDK、JRE

##### JVM

**什么是字节码？采用字节码的好处是什么**

> 在 Java 中，JVM 可以理解的代码就叫做 **字节码**（即扩展名为 .class 的文件），它只面向虚拟机。

Java 程序从源代码到运行一般有下面 3 步：

<img src="https://raw.githubusercontent.com/whn961227/images/master/data/image-20200720225705419.png" alt="image-20200720225705419" style="zoom:80%;" />

格外注意 .class -> 机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的（也就是所谓的热点代码），所以后面引进了 **JIT 编译器**，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。机器码的运行效率肯定是高于 Java 解释器的。这也解释了为什么 Java 是编译与解释共存的语言

**总结：**

* Java 虚拟机（JVM）是运行 Java 字节码的虚拟机

* JVM 有针对不同系统的特定实现（Windows、Linux、macOS），目的是使用相同的字节码，他们都会给出相同的结果
* 字节码和不同系统的 JVM 实现是 Java 语言 “一次编译，随处可以运行” 的关键所在

##### JDK 和 JRE

JDK 是 Java Development Kit，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（Javac）和工具（如 Javadoc 和 jdb）。它能够创建和编译程序

JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java虚拟机（JVM），Java 类库，Java 命令和其他的一些基础构件。但是，它不能用于创建新程序



#### 为什么说 Java 语言“编译与解释并存”？

高级编程语言按照程序的执行方式分为 **编译型** 和 **解释型** 两种。

**编译型语言 **是指编译器针对特定的操作系统将源代码一次性翻译成可被该平台执行的机器码

**解释型语言** 是指解释器对源程序逐行解释成特定平台的机器码并立即执行

Java 程序要经过先编译，后解释两个步骤，经过编译步骤，生成字节码（.class文件），这种字节码必须由 Java 解释器来解释执行



#### 



### Java 中的四种代码块

#### 简介

* **普通代码块：**定义在方法中（不管是静态方法还是普通方法） -> 方法被调用时执行
* **构造代码块：**直接定义在类中，但是没有 static -> 优先于构造方法执行，晚于静态块执行
* **静态代码块：**定义在类中，且有 static -> 最先被执行，且对于一个类的多个对象，只执行一次
* **同步代码块：**synchronized 关键字修饰的，和线程相关

#### 静态代码块和构造代码块的区别

**相同点：**都是 JVM 加载类后且在构造方法前执行，在类中可定义多个，一般在代码块中对一些 static 变量进行赋值

**不同点：**静态代码块在构造代码块前执行。静态代码块只在第一次 new 时执行一次，之后不再执行。而构造代码块每 new 一次就执行一次

#### 示例

```java
public class Person {
    static{
        System.out.println("1.我是静态块，优先于构造块执行！并且只有创建第一个对象的时候执行一次！");
    }
    {
        System.out.println("2.我是构造块，优先于构造方法执行！每创建一个对象执行一次！");
    }
    public Person() {
        System.out.println("3.我是构造方法，每创建一个对象执行一次");
    }
    public void function1(){
        System.out.println("我是非静态方法中的普通代码块，方法被调用时执行！");
    }
    public static void function2(){
        System.out.println("我是静态方法中的普通代码块，方法被调用时执行，晚于静态块执行！");
    }
}

public class HelloWrold {
    public static void main(String[] args) {
        new Person().function1();
        new Person().function1();
        System.out.println("=================");
        Person.function2();
        Person.function2();
    }
}

/**
 *	1.我是静态块，优先于构造块执行！并且只有创建第一个对象的时候执行一次！
 *	2.我是构造块，优先于构造方法执行！每创建一个对象执行一次！
 *	3.我是构造方法，每创建一个对象执行一次
 *	我是非静态方法中的普通代码块，方法被调用时执行！
 *	2.我是构造块，优先于构造方法执行！每创建一个对象执行一次！
 *	3.我是构造方法，每创建一个对象执行一次
 * 	我是非静态方法中的普通代码块，方法被调用时执行！
 *	=================
 * 	我是静态方法中的普通代码块，方法被调用时执行，晚于静态块执行！
 * 	我是静态方法中的普通代码块，方法被调用时执行，晚于静态块执行！
 */
```

可以看出：静态块总是最先执行的，并且只有在创建类的第一个实例的时候才会执行一次；第二执行的是构造块；第三执行的是构造方法



### 泛型

即“参数化类型”，就是将类型由原来具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）

在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别称为泛型类、泛型接口和泛型方法

它提供了编译期的类型安全

#### Java 的泛型是如何工作的？什么是类型擦除？

泛型是通过类型擦除实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。你无法在运行时访问到类型参数，因为编译器已经把泛型类型转换成了原始类型。

#### 什么是泛型中的限定通配符和非限定通配符？

限定通配符对类型进行了限制。有两种限定通配符，一种是 <? extends T>，它确保类型必须是 T 的子类来设定类型的上界，另一种是 <? super T>，它通过确保类型必须是 T 的父类来设定类型的下届。泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。另一方面 < ? > 表示了非限定通配符，因为 < ? > 可以用任意类型来替代。 

