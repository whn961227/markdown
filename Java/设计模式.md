## 设计模式

### 单例模式

> **定义**

单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以**保证系统中一个类只有一个实例**

> **特点**

1. 单例类只能有一个实例。
2. 单例类必须自己创建自己的唯一实例。
3. 单例类必须给所有其他对象提供这一实例

> **要点**

1. 私有的构造方法
2. 指向自己实例的私有静态引用
3. 以自己实例为返回值的静态的公有的方法

> **根据实例化对象时机的不同分为两种：**

一种是**饿汉式**单例，一种是**懒汉式**单例

饿汉式单例在**单例类被加载**时候，就实例化一个对象交给自己的引用；

懒汉式在**调用取得实例方法的时候才会实例化对象**

```java
// 饿汉式
public class Singleton {
    private static Singleton singleton = new Singleton();
    private Singleton(){}
    public static Singleton getInstance() {
        return singleton;
	}
}

// 懒汉式
public class Singleton {
    private static Singleton singleton;
    private Singleton(){}
    public static synchronized Singleton getInstance() {
        if (singleton == null) {
            singleton = new Singleton();
        }
        return singleton;
    }
}
```

**单例模式还有一种比较常见的形式：双重锁的形式**

```java
public class Singleton {
    private static volatile Singleton instance = null;
    private Singleton(){}
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized(Singleton.class) {
                if (instance == null){
                	instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

> **优点**

1. 在内存中只有一个对象，节省内存空间。
2. 避免频繁的创建销毁对象，可以提高性能。
3. 避免对共享资源的多重占用。
4. 可以全局访问。

> **缺点**

1. 扩展困难，由于getInstance静态函数没有办法生成子类的实例。如果要拓展，只有重写那个类。
2. 隐式使用引起类结构不清晰。
3. 导致程序内存泄露的问题。

> **适用场景**

1. 需要频繁实例化然后销毁的对象。
2. 创建对象时耗时过多或者耗资源过多，但又经常用到的对象。
3. 资源共享的情况下，避免由于资源操作时导致的性能或损耗等
4. 控制资源的情况下，方便资源之间的互相通信。