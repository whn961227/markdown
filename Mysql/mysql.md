## MySQL

### 管理员必备技能

#### MySQL 权限工作原理

**mysql是如何来识别一个用户的呢？**

mysql为了安全性考虑，采用`主机名+用户名`来判断一个用户的身份

**Mysql权限验证分为2个阶段：**

1. 阶段1：连接数据库，此时mysql会根据你的用户名及你的来源（ip或者主机名称）**判断是否有权限连接**
2. 阶段2：对mysql服务器发起请求操作，如create table、select、delete、update、create index等操作，此时mysql会判断你**是否有权限操作这些指令**

#### 权限生效时间

**用户及权限信息放在库名为mysql的库中**，mysql启动时，这些内容被读进内存并且从此时生效，所以如果通过直接操作这些表来修改用户及权限信息的，需要`重启mysql`或者执行`flush privileges;`才可以生效。

**用户登录之后，mysql会和当前用户之间创建一个连接，此时用户相关的权限信息都保存在这个连接中**，存放在内存中，此时如果有其他地方修改了当前用户的权限，这些变更的权限会在下一次登录时才会生效。

#### 查看 MySQL 中所有用户

用户信息在`mysql.user`表中，如下：

```
mysql> use mysql;
Database changed
mysql> select user,host from user;
+---------------+--------------+
| user          | host         |
+---------------+--------------+
| test4         | 127.0.0.%    |
| test4         | 192.168.11.% |
| mysql.session | localhost    |
| mysql.sys     | localhost    |
| root          | localhost    |
| test2         | localhost    |
+---------------+--------------+
6 rows in set (0.00 sec)
```

####  创建用户

**语法：**

```sql
create user 用户名[@主机名] [identified by '密码']
```

> 说明：
>
> 1. 主机名默认值为 % ，表示这个用户可以从任何主机连接mysql服务器
> 2. 密码可以省略，表示无密码登录

#### 修改密码【3 种方式】

#### 给用户授权

创建用户之后，需要给用户授权，才有意义。

语法：

```sql
grant privileges ON database.table TO 'username'[@'host'] [with grant option]
```

**grant命令说明：**

* privileges (权限列表)，可以是`all`，表示所有权限，也可以是`select、update`等权限，多个权限之间用逗号分开。
* ON 用来指定权限针对哪些库和表，格式为`数据库.表名` ，点号前面用来指定数据库名，点号后面用来指定表名，`*.*` 表示所有数据库所有表。
* TO 表示将权限赋予某个用户, 格式为`username@host`，@前面为用户名，@后面接限制的主机，可以是IP、IP段、域名以及%，%表示任何地方。
* WITH GRANT OPTION 这个选项表示该用户可以将自己拥有的权限授权给别人。注意：经常有人在创建操作用户的时候不指定WITH GRANT OPTION选项导致后来该用户不能使用GRANT命令创建用户或者给其它用户授权。

*备注：可以使用GRANT重复给用户添加权限，权限叠加，比如你先给用户添加一个select权限，然后又给用户添加一个insert权限，那么该用户就同时拥有了select和insert权限。*

#### 查看用户有哪些权限

**show grants for '用户名'[@'主机']**

**show grants; **查看当前用户的权限

#### 撤销用户的权限

**语法**

```sql
revoke privileges ON database.table FROM '用户名'[@'主机'];
```

可以先通过`show grants`命令查询一下用户对于的权限，然后使用`revoke`命令撤销用户对应的权限

#### 删除用户【2 种方式】

**方式1：**

**drop user '用户名'[@‘主机’]**

**方式2：**

通过删除 mysql.user 表数据的方式删除，注意通过表的方式删除的，需要调用`flush privileges;`刷新权限信息（权限启动的时候在内存中保存着，通过表的方式修改之后需要刷新一下）。

### 数据库三大设计范式

* **1NF**

  **不可分割**性，只要字段值还可以继续拆分，就不满足第一范式。

  不可分割的意思就按字面理解就是最小单位，不能再分成更小单位了。

  字段只能是一个值，不能被拆分成多个字段，否则的话，它就是可分割的，就不符合一范式。

* **2NF**

  第二范式就是要有**主键**，**要求其他字段都依赖于主键**。

  为什么要有主键？没有主键就没有唯一性，没有唯一性在集合中就定位不到这行记录，所以要主键。

  在满足第一范式的前提下，**主键外的每一列都必须完全依赖于主键**。如果出现不完全依赖，只可能发生在联合主键的情况下。

* **3NF**

  在满足第二范式的前提下，除了主键列之外，**其他列之间不能有传递依赖关系**，即“消除冗余”。

  消除冗余，就是各种信息只在一个地方存储，不出现在多张表中。

  

### 详解事务

#### 什么是事务

**数据库中的事务是指对数据库执行一批操作，这些操作最终要么全部执行成功，要么全部失败，不会存在部分成功的情况。**

#### 事务的几个特性（ACID）

**原子性（Atomicity）**

事务的整个过程如**原子操作**一样，最终要么全部成功，或者全部失败，这个原子性是从最终结果来看的，从最终结果来看这个过程是**不可分割**的。

**一致性（Consistency）**

事务开始之前、执行中、执行完毕，这些时间点，多个人去观察事务操作的数据的时候，看到的**数据都是一致**的。

**隔离性（Isolation）**

一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是**隔离**的，并发执行的各个事务之间不能互相干扰。

**持久性（Durability）**

一个事务一旦提交，他**对数据库中数据的改变就应该是永久性**的。当事务提交之后，数据会持久化到硬盘，修改是永久性的。

#### MySQL 中的事务操作

mysql中事务默认是隐式事务，执行insert、update、delete操作的时候，数据库自动开启事务、提交或回滚事务。

是否开启隐式事务是由变量`autocommit`控制的。

所以事务分为**隐式事务**和**显式事务**。

##### 隐式事务

> 事务自动开启、提交或回滚，比如insert、update、delete语句，事务的开启、提交或回滚由mysql内部自动控制的。

查看变量`autocommit`是否开启了自动提交

```sql
mysql> show variables like 'autocommit';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | ON    |
+---------------+-------+
```

> `autocommit`为ON表示开启了自动提交。

##### 显式事务

> 事务需要手动开启、提交或回滚，由开发者自己控制。

2 种方式手动控制事务：

**方式1：**

语法：

```sql
//设置不自动提交事务
set autocommit=0;
//执行事务操作
commit|rollback;
```

**方式2：**

语法：

```sql
start transaction;//开启事务
//执行事务操作
commit|rollback;
```

##### savepoint 关键字

在事务中我们执行了一大批操作，可能我们只想回滚部分数据，怎么做呢？

我们可以将一大批操作分为几个部分，然后指定回滚某个部分。可以使用`savepoint`来实现，效果如下：

```sql
mysql> start transaction;
Query OK, 0 rows affected (0.00 sec)

mysql> insert into test1 values (1);
Query OK, 1 row affected (0.00 sec)

mysql> savepoint part1;//设置一个保存点
Query OK, 0 rows affected (0.00 sec)

mysql> insert into test1 values (2);
Query OK, 1 row affected (0.00 sec)

mysql> rollback to part1;//将savepint = part1的语句到当前语句之间所有的操作回滚
Query OK, 0 rows affected (0.00 sec)

mysql> commit;//提交事务
Query OK, 0 rows affected (0.00 sec)

mysql> select * from test1;
+------+
| a    |
+------+
|    1 |
+------+
1 row in set (0.00 sec)
```

> 从上面可以看出，执行了2次插入操作，最后只插入了1条数据。
>
> `savepoint`需要结合`rollback to sp1`一起使用，可以将保存点`sp1`到`rollback to`之间的操作回滚掉。

##### 只读事务

表示在事务中执行的是一些只读操作，如查询，但是不会做insert、update、delete操作，数据库内部对只读事务可能会有一些性能上的优化。

用法如下：

```sql
start transaction read only;
```

示例：

```sql
mysql> commit;
Query OK, 0 rows affected (0.00 sec)

mysql> start transaction read only;
Query OK, 0 rows affected (0.00 sec)

mysql> select * from test1;
+------+
| a    |
+------+
|    1 |
|    1 |
+------+
2 rows in set (0.00 sec)

mysql> delete from test1;
ERROR 1792 (25006): Cannot execute statement in a READ ONLY transaction.
mysql> commit;
Query OK, 0 rows affected (0.00 sec)

mysql> select * from test1;
+------+
| a    |
+------+
|    1 |
|    1 |
+------+
2 rows in set (0.00 sec)
```

> 只读事务中执行 delete 会报错

#### 事务中的问题

这些问题主要是基于数据在多个事务中的可见性来说的。

##### 脏读

一个事务在执行的过程中**读取到了其他事务还没有提交的数据**。

##### 不可重复读

同一事务内多次读取同一数据集合结果不一致（多次查询间隔中其他事务提交修改了数据）

##### 幻读

**事务中后面的操作（插入号码X）需要上面的读取操作（查询号码X的记录）提供支持，但读取操作却不能支持下面的操作时产生的错误，就像发生了幻觉一样。**

#### 事务的隔离级别

**隔离级别分为4种：**

1. **读未提交：READ-UNCOMMITTED**
2. **读已提交：READ-COMMITTED**
3. **可重复读：REPEATABLE-READ**
4. **串行：SERIALIZABLE**

上面4中隔离级别越来越强，会导致数据库的并发性也越来越低。

##### 查看隔离级别

```sql
mysql> show variables like 'transaction_isolation';
+-----------------------+-----------------+
| Variable_name         | Value           |
+-----------------------+-----------------+
| transaction_isolation | REPEATABLE-READ |
+-----------------------+-----------------+
```

##### 隔离级别的设置

```sql
mysql> set global transaction isolation level read committed; //全局的
mysql> set session transaction isolation level read committed; //当前会话
```

##### 各种隔离级别中会出现的问题

| 隔离级别         | 脏读 | 不可重复读 | 幻读 |
| ---------------- | ---- | ---------- | ---- |
| READ-UNCOMMITTED | 有   | 有         | 无   |
| READ-COMMITTED   | 无   | 有         | 无   |
| REPEATABLE-READ  | 无   | 无         | 有   |
| SERIALIZABLE     | 无   | 无         | 无   |

#### 隔离级别的选择

1. 需要对各种隔离级别产生的现象非常了解，然后选择的时候才能游刃有余
2. 隔离级别越高，并发性也低，比如最高级别`SERIALIZABLE`会让事物串行执行，并发操作变成串行了，会导致系统性能直接降低。
3. 具体选择哪种需要结合具体的业务来选择。
4. 读已提交（READ-COMMITTED）通常用的比较多。



### 详解视图

#### 什么是视图

##### 概念

视图是在mysql5之后出现的，是一种虚拟表，行和列的数据来自于定义视图时使用的一些表中，**视图的数据是在使用视图的时候动态生成的，视图只保存了sql的逻辑，不保存查询的结果**。

##### 使用场景

多个地方使用到同样的查询结果，并且该查询结果比较复杂的时候，我们可以使用视图来隐藏复杂的实现细节。

##### 视图和表的区别

|      | 语法         | 实际中是否占用物理空间 | 使用                           |
| ---- | ------------ | ---------------------- | ------------------------------ |
| 视图 | create view  | 只是保存了sql的逻辑    | 增删改查，实际上我们只使用查询 |
| 表   | create table | 保存了数据             | 增删改查                       |

##### 视图的好处

* 简化复杂的sql操作，不用知道他的实现细节
* 隔离了原始表，可以不让使用视图的人接触原始的表，从而保护原始数据，提高了安全性

#### 创建视图

##### 语法

```sql
create view 视图名
as
查询语句;
```

##### 视图的使用步骤

* 创建视图
* 对视图执行查询操作

#### 修改视图

##### 方式一

> 如果该视图存在，就修改，如果不存在，就创建新的视图。

```sql
create or replace view 视图名
as
查询语句;
```

##### 方式二

```sql
alter view 视图名
as 
查询语句;
```

#### 删除视图

```sql
drop view 视图名1 [,视图名2] [,视图名n];
```

#### 查询视图结构

```sql
/*方式1*/
desc 视图名称;
/*方式2*/
show create view 视图名称;
```



### SQL JOIN 连接查询

首先，设定两张表，作为下面例子的操作对象。

表1 学生信息表

![img](https://pic2.zhimg.com/80/v2-5ce6367d37234828fb5e5958113e6a51_720w.jpg)

表2 专业班级表

![img](https://pic2.zhimg.com/80/v2-871f75983ed7a802c9acb76541278fec_720w.jpg)

SQL JOIN连接查询各种用法

<img src="https://pic4.zhimg.com/80/v2-7dd2e77f2d94fb2752900b05ba7ae67b_720w.jpg" alt="img"  />

#### Inner Join 内连接

这是最常用的，**获取两个表中指定字段满足匹配关系的记录**。

![img](https://pic4.zhimg.com/80/v2-eaa5d9a2aa94c71d0a0633339481afd9_720w.jpg)

内连接通常有两种情况：

**等值连接：**查找两个表中连接字段相等的记录

```sql
--查询每个学生的学号、姓名、籍贯、年龄、专业、班级
--涉及到 student 和 major 两张表，用共有字段“学号”为连接字段

--写法1：使用 INNER JOIN
SELECT A.学号, A.姓名, A.籍贯, A.年龄, B.专业, B.班级
FROM student A
INNER JOIN major B   
ON  A.学号=B.学号

--写法2：--省去了INNER，直接写JOIN，与INNER JOIN没有区别
SELECT A.学号, A.姓名, A.籍贯, A.年龄, B.专业, B.班级
FROM student A
JOIN major B  
ON  A.学号=B.学号

--写法3： --使用WHERE，已经逐渐被淘汰
SELECT A.学号, A.姓名, A.籍贯, A.年龄, B.专业, B.班级
FROM student A, major B
WHERE A.学号=B.学号 

--上面三种写法的结果都是一样的，推荐使用写法2
```

![img](https://pic4.zhimg.com/80/v2-e5ad3fb64a5d33027a2615ac67026785_720w.jpg)

**自身连接：**就是和自己进行连接查询，给一张表取两个不同的别名，然后附上连接条件。

```sql
--要在学生表里查询与 HH 同龄且籍贯也相同的学生信息
SELECT B.学号, B.姓名, B.性别, B.籍贯, B.年龄
FROM student A
JOIN student B
ON A.年龄=B.年龄 AND A.籍贯=B.籍贯 AND A.姓名='HH'
```

![img](https://pic2.zhimg.com/80/v2-482a63b111a16667d8541e332f44dd01_720w.jpg)

#### Left Join 左连接

获取左表中的所有记录，即使在右表没有对应匹配的记录。

![img](https://pic1.zhimg.com/80/v2-45fcd21c1199f2ff71ecf1231a18c86b_720w.jpg)

```sql
--左连接：显示左表student所有记录，如右表中没有与之
--匹配的项则以NULL值代替。

SELECT A.学号, A.姓名, A.籍贯, A.年龄, B.专业, B.班级
FROM student A LEFT JOIN major B  
ON  A.学号=B.学号
```

![img](https://pic4.zhimg.com/80/v2-4e7bedab0b48f3d0ce3ee2b500903834_720w.jpg)

#### Right Join 右连接

用于获取右表中的所有记录，即使左表没有对应匹配的记录。

![img](https://pic1.zhimg.com/80/v2-742cc2400cf90e34e4b19d0587047dec_720w.jpg)

```sql
--右连接：显示右表major所有记录，如左表中没有与之
--匹配的项则以NULL值代替。

SELECT A.学号, A.姓名, A.籍贯, A.年龄, B.专业, B.班级
FROM student A RIGHT JOIN major B  
ON  A.学号=B.学号
```

![img](https://pic1.zhimg.com/80/v2-5ed2e1d82e92575ba60778511949701d_720w.jpg)

#### Full Join 完全连接

返回两个表中的所有行。

![img](https://pic4.zhimg.com/80/v2-4da74dd801c81a61eb10e3699d87e4c6_720w.jpg)

```sql
--完全连接：显示两张表的并集，如果其中一张表的记录
--在另一张表中没有匹配的行，则对应的数据项填充NULL

SELECT A.学号, A.姓名, A.籍贯, A.年龄, B.专业, B.班级
FROM student A FULL JOIN major B  
ON  A.学号=B.学号
```

![img](https://pic3.zhimg.com/80/v2-b0ae779aafbbff6f190db1e49df46be2_720w.jpg)

#### Cross Join 交叉连接

结果是笛卡尔积，就是第一个表的行数乘以第二个表的行数。

![img](https://pic1.zhimg.com/80/v2-37cd1d45bb26a92bd54cedf7e8976692_720w.jpg)

```sql
--交叉连接：一张表中的数据依次取出分别与另一张表中的
--每条数据挨个组合，最后记录数量为两张表记录数的乘积

SELECT * FROM student CROSS JOIN major

--本例student和major都为7条记录，所以结果为7*7=49条记录
```

![img](https://pic1.zhimg.com/v2-dd567fe9dcef9e2a77cb14cd6054c329_b.webp)





### SQL 执行过程

<img src="https://raw.githubusercontent.com/whn961227/images/master/data/20200805092702.png" style="zoom: 33%;" />

1. 客户端发送一条查询给服务器
2. 服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段
3. 服务器进行 SQL 解析、预处理，再由优化器生成对应的执行计划
4. MySql 根据优化器生成的执行计划，再调用存储引擎的 API 来执行查询
5. 将结果返回给客户端

#### 连接

SQL 客户端与服务器建立连接，该请求被发送到连接管理器，连接成功后会验证权限等，这过程其实就是一个 TCP 连接的过程。

验证ok后，我们就连上了这个MySQL服务了，但是这个时候我们处于空闲状态。

> 注意：MySql 服务器与客户端之间的通信是 **半双工** 的

> **怎么查看空闲连接列表？**

**show processlist**，下图就是我在自己的数据库表执行命令的结果，其中的 Command 列显示为 **Sleep** 的这一行，就表示现在系统里面有一个空闲连接。

![img](https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1FpwRDhU2sroFJqmyXeCW1PAQfSuSMmRLVlnmYY5ZlpKVDPjawBTEqbVbTKK0hUYXiaoJLLKfX6DFx2A/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

这里需要注意的是，我们数据库的客户端太久没响应，连接器就会自动断开了，这个时间参数是 **wait_timeout** 控制住的，默认时长为 8 小时。

断开后重连的时候会报错，如果你想再继续操作，你就需要重连了。

> **那除了重新链接，还有别的方式么？**因为建立链接还是比较麻烦的。

使用**长连接**。

但是这里有个缺点，使用长连接之后，**内存会飙得很快**，我们知道 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。

只有在链接断开的时候才能得到释放，那如果一直使用长连接，那就会**导致 OOM（Out Of Memory）**，会导致 MySQL 重启，在 JVM 里面就会导致频繁的 Full GC。

> **怎么解决？**

执行比较大的一个查询后，执行 **mysql_reset_connection** 可以**重新初始化连接资源**。这个过程不需要重连，但是会初始化连接的状态。

#### 查询缓存

MySql 查询缓存保存**查询返回的完整结构**。当查询命中该缓存时，MySql 会立刻返回结果，跳过了解析、优化和执行阶段。

**缓存的失效很容易**，**只要对表有任何的更新**，**这个表的所有查询缓存就会全部被清空**，就会出现缓存还没使用，就直接被清空了，或者积累了很多缓存准备用来着，但是一个更新打回原形。

这就**导致查询的命中率低**的可怕，只有那种**只查询不更新的表适用缓存**，但是这s样的表往往很少存在，一般都是什么配置表之类的。

> 查询的时候不想用缓存一般都是怎么操作的，或者是用缓存又怎么操作？

可以显示调用，把 **query_cache_type** 设置成为 DEMAND，这样 SQL 默认不使用缓存，想用缓存就用 SQL_CACHE。

缓存在 MySQL 8.0 之后就**取消**了

#### 解析和预处理

**解析器**通过关键字将 SQL 语句进行**解析**，并**生成对应的解析树**。MySql 解析器将**使用 MySql 语法规则验证**和**解析查询**。

**预处理器**则**根据一些 MySql 规则进行进一步检查解析树是否合法**，例如检查数据表和数据列是否存在，还会解析名字和别名。看看它们是否有歧义

#### 查询优化器

**查询优化器**会**将解析树转换成执行计划**。一条查询可以有多种执行方法，最后都是返回相同结果，**优化器的作用就是找到其中最好的执行计划。**

因为我们建立表可能会建立很多索引，优化有一步就是要确认使用哪个索引，比如使用你的主键索引，联合索引还是什么索引更好。还有就是对执行顺序进行优化，条件那么多，先查哪个表，还是先关联，会出现很多方案，最后由优化器决定选用哪种方案。

生成执行计划的过程会消耗较多的时间，特别是存在许多可选的执行计划时

如果在一条 SQL 语句执行的过程中将该语句对应的**最终执行计划进行缓存**，当相似的语句再次被输入服务器时，就可以直接使用已缓存的执行计划，从而跳过 SQL 语句生成执行计划的整个过程，进而可以提高语句的执行速度

<img src="https://raw.githubusercontent.com/whn961227/images/master/data/20200805102651.png" style="zoom:25%;" />

MySql 使用**基于成本的查询优化器**。它会尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最少的一个

#### 查询执行引擎

在解析和优化阶段，MySql 将生成查询对应的执行计划，MySql 的查询执行引擎根据这个执行计划来完成整个查询。这里执行计划是一个数据结构，而不是和其他的关系型数据库那样生成对应的字节码

#### 返回结果给客户端

如果查询可以被缓存，那么 MySql 在这个阶段会**将结果存放到查询缓存**中

MySql 将结果集返回给客户端是一个增量、逐步返回的过程。在查询生成第一条结果时，MySql 就可以开始向客户端逐步返回结果集了

### MySQL 索引原理

#### 索引的目的

提高查询效率

#### 索引原理

数据库也是一样，但显然要复杂许多，因为不仅面临着等值查询，还有范围查询(>、<、between、in)、模糊查询(like)、并集查询(or)等等。数据库应该选择怎么样的方式来应对所有的问题呢？我们回想字典的例子，能不能把数据分成段，然后分段查询呢？最简单的如果1000条数据，1到100分成第一段，101到200分成第二段，201到300分成第三段……这样查第250条数据，只要找第三段就可以了，一下子去除了90%的无效数据。但如果是1千万的记录呢，分成几段比较好？稍有算法基础的同学会想到**搜索树**，其**平均复杂度是 lgN**，具有不错的查询性能。但这里我们忽略了一个关键的问题，复杂度模型是基于每次相同的操作成本来考虑的，数据库实现比较复杂，**数据保存在磁盘上，而为了提高性能，每次又可以把部分数据读入内存来计算**，因为我们知道访问磁盘的成本大概是访问内存的十万倍左右，所以简单的搜索树难以满足复杂的应用场景。

##### 磁盘 IO 与预读

磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为**寻道时间、旋转延迟、传输时间**三个部分，**寻道时间指的是磁臂移动到指定磁道所需要的时间**，**旋转延迟就是我们经常听说的磁盘转速**，**传输时间指的是从磁盘读出或将数据写入磁盘的时间**

考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，**当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内**，因为**局部预读性原理**告诉我们，**当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到**。**每一次IO读取的数据我们称之为一页(page)**。具体一页有多大数据跟操作系统有关，**一般为4k或8k**，也就是我们读取一页内的数据时候，实际上才发生了一次 IO，这个理论对于索引的数据结构设计非常有帮助

##### 索引的数据结构

每次查找数据时把磁盘IO次数控制在一个很小的数量级，最好是常数数量级。那么我们就想到如果一个高度可控的多路搜索树是否能满足需求呢？就这样，**b+ 树**应运而生

##### 详解 B+ 树

![b+树](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2014/7af22798.jpg)

如上图，是一颗b+树，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。**真实的数据存在于叶子节点**即3、5、9、10、13、15、28、29、36、60、75、79、90、99。**非叶子节点不存储真实的数据，只存储指引搜索方向的数据项**，如17、35并不真实存在于数据表中

##### B+ 树的查找过程

如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用**二分查找**确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。

##### B+ 树的性质

1. 通过上面的分析，我们知道IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有
   $$
   h = log_{m+1}N
   $$
   当数据量N一定的情况下，m越大，h越小；而 
   $$
   m = 磁盘块的大小 / 数据项的大小
   $$
   **磁盘块的大小也就是一个数据页的大小，是固定的**，如果**数据项占的空间越小**，**数据项的数量越多**，**树的高度越低**。这就是为什么每个**数据项**，即**索引字段要尽量的小**，比如int占4字节，要比bigint8字节少一半。这也是为什么 b+ 树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。

2. **当 b+ 树的数据项是复合的数据结构**，比如(name,age,sex)的时候，**b+ 树是按照从左到右的顺序来建立搜索树的**，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的**最左匹配特性**。

#### 分类

1. 按**存储结构**划分：BTree索引（B+Tree索引），Hash索引，full-index全文索引，R-Tree索引。
2. 按**应用层次**划分：普通索引，唯一索引，复合索引。
   * **普通索引**：即一个索引只包含单个列，一个表可以有多个单列索引
   * **唯一索引**：索引列的值必须唯一，但允许有空值
   * **复合索引**：即一个索引包含多个列
3. 根据数据的物理顺序与键值的逻辑（索引）顺序关系：聚集索引，非聚集索引。
   * **聚簇索引(聚集索引)**：并不是一种单独的索引类型，而是一种数据存储方式。具体细节取决于不同的实现，InnoDB的聚簇索引其实就是在同一个结构中保存了B+Tree索引和数据行。
   * **非聚簇索引**：不是聚簇索引，就是非聚簇索引。

### 慢查询优化

#### 建索引的几大原则

1. **最左前缀匹配原则**，非常重要的原则，**mysql 会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配**，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。

2. **= 和 in 可以乱序**，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，**mysql 的查询优化器会帮你优化成索引可以识别的形式**。

3. **尽量选择区分度高的列作为索引**，区分度的公式是
   $$
   区分度 = \frac{count( distinct(col))}{count(*)}
   $$
   表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。

4. **索引列不能参与计算，保持列“干净”**，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。
5. **尽量的扩展索引，不要新建索引**。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。

#### 查询优化神器 - explain 命令

![](https://raw.githubusercontent.com/whn961227/images/master/data/20200830112507.png)

* id：select 查询的标识符，每个 select 都会自动分配一个唯一的标识符
* select_type：select 查询的类型
  * simple：表示此查询不包含 UNION 查询或子查询
  * PRIMARY：表示此查询是最外层的查询
  * UNION：表示此查询是 UNION 的第二或随后的查询
* table：查询的是哪个表
* type：join 类型
* possible_keys：此次查询中可能选用的索引
* key：此次查询中确切使用到的索引
* key_len：索引字段长度
* ref：哪个字段或常数与 key 一起被使用
* rows：显示此查询一共扫描了多少行，这是一个估计值
* extra：额外的信息



### SQL 执行顺序

查询中用到的关键词主要包含六个，并且他们的顺序依次为 

select--from--where--group by--having--order by 

六个关键词的执行顺序为

**from--where--group by--having--select--order by**

from：需要从哪个数据表检索数据 

where：过滤表中数据的条件

group by：如何将上面过滤出的数据分组

having：对上面已经分组的数据进行过滤的条件

select：查看结果集中的哪个列，或列的计算结果 

order by：按照什么样的顺序来查看返回的数据 



### 参考资料

[MySQL索引原理及慢查询优化]: https://tech.meituan.com/2014/06/30/mysql-index.html

