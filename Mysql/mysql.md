## MySQL

### 数据库三大设计范式

* **1NF**

  **不可分割**性，只要字段值还可以继续拆分，就不满足第一范式。

  不可分割的意思就按字面理解就是最小单位，不能再分成更小单位了。

  字段只能是一个值，不能被拆分成多个字段，否则的话，它就是可分割的，就不符合一范式。

* **2NF**

  第二范式就是要有**主键**，**要求其他字段都依赖于主键**。

  为什么要有主键？没有主键就没有唯一性，没有唯一性在集合中就定位不到这行记录，所以要主键。

  在满足第一范式的前提下，**主键外的每一列都必须完全依赖于主键**。如果出现不完全依赖，只可能发生在联合主键的情况下。

* **3NF**

  在满足第二范式的前提下，除了主键列之外，**其他列之间不能有传递依赖关系**，即“消除冗余”。

  消除冗余，就是各种信息只在一个地方存储，不出现在多张表中。

  

### SQL JOIN 连接查询

首先，设定两张表，作为下面例子的操作对象。

表1 学生信息表

![img](https://pic2.zhimg.com/80/v2-5ce6367d37234828fb5e5958113e6a51_720w.jpg)

表2 专业班级表

![img](https://pic2.zhimg.com/80/v2-871f75983ed7a802c9acb76541278fec_720w.jpg)

SQL JOIN连接查询各种用法

<img src="https://pic4.zhimg.com/80/v2-7dd2e77f2d94fb2752900b05ba7ae67b_720w.jpg" alt="img"  />

#### Inner Join 内连接

这是最常用的，**获取两个表中指定字段满足匹配关系的记录**。

![img](https://pic4.zhimg.com/80/v2-eaa5d9a2aa94c71d0a0633339481afd9_720w.jpg)

内连接通常有两种情况：

**等值连接：**查找两个表中连接字段相等的记录

```sql
--查询每个学生的学号、姓名、籍贯、年龄、专业、班级
--涉及到 student 和 major 两张表，用共有字段“学号”为连接字段

--写法1：使用 INNER JOIN
SELECT A.学号, A.姓名, A.籍贯, A.年龄, B.专业, B.班级
FROM student A
INNER JOIN major B   
ON  A.学号=B.学号

--写法2：--省去了INNER，直接写JOIN，与INNER JOIN没有区别
SELECT A.学号, A.姓名, A.籍贯, A.年龄, B.专业, B.班级
FROM student A
JOIN major B  
ON  A.学号=B.学号

--写法3： --使用WHERE，已经逐渐被淘汰
SELECT A.学号, A.姓名, A.籍贯, A.年龄, B.专业, B.班级
FROM student A, major B
WHERE A.学号=B.学号 

--上面三种写法的结果都是一样的，推荐使用写法2
```

![img](https://pic4.zhimg.com/80/v2-e5ad3fb64a5d33027a2615ac67026785_720w.jpg)

**自身连接：**就是和自己进行连接查询，给一张表取两个不同的别名，然后附上连接条件。

```sql
--要在学生表里查询与 HH 同龄且籍贯也相同的学生信息
SELECT B.学号, B.姓名, B.性别, B.籍贯, B.年龄
FROM student A 
JOIN student B
ON A.年龄=B.年龄 AND A.籍贯=B.籍贯 AND A.姓名='HH'
```

![img](https://pic2.zhimg.com/80/v2-482a63b111a16667d8541e332f44dd01_720w.jpg)

#### Left Join 左连接

获取左表中的所有记录，即使在右表没有对应匹配的记录。

![img](https://pic1.zhimg.com/80/v2-45fcd21c1199f2ff71ecf1231a18c86b_720w.jpg)

```sql
--左连接：显示左表student所有记录，如右表中没有与之
--匹配的项则以NULL值代替。

SELECT A.学号, A.姓名, A.籍贯, A.年龄, B.专业, B.班级
FROM student A LEFT JOIN major B  
ON  A.学号=B.学号
```

![img](https://pic4.zhimg.com/80/v2-4e7bedab0b48f3d0ce3ee2b500903834_720w.jpg)

#### Right Join 右连接

用于获取右表中的所有记录，即使左表没有对应匹配的记录。

![img](https://pic1.zhimg.com/80/v2-742cc2400cf90e34e4b19d0587047dec_720w.jpg)

```sql
--右连接：显示右表major所有记录，如左表中没有与之
--匹配的项则以NULL值代替。

SELECT A.学号, A.姓名, A.籍贯, A.年龄, B.专业, B.班级
FROM student A RIGHT JOIN major B  
ON  A.学号=B.学号
```

![img](https://pic1.zhimg.com/80/v2-5ed2e1d82e92575ba60778511949701d_720w.jpg)

#### Full Join 完全连接

返回两个表中的所有行。

![img](https://pic4.zhimg.com/80/v2-4da74dd801c81a61eb10e3699d87e4c6_720w.jpg)

```sql
--完全连接：显示两张表的并集，如果其中一张表的记录
--在另一张表中没有匹配的行，则对应的数据项填充NULL

SELECT A.学号, A.姓名, A.籍贯, A.年龄, B.专业, B.班级
FROM student A FULL JOIN major B  
ON  A.学号=B.学号
```

![img](https://pic3.zhimg.com/80/v2-b0ae779aafbbff6f190db1e49df46be2_720w.jpg)

#### Cross Join 交叉连接

结果是笛卡尔积，就是第一个表的行数乘以第二个表的行数。

![img](https://pic1.zhimg.com/80/v2-37cd1d45bb26a92bd54cedf7e8976692_720w.jpg)

```sql
--交叉连接：一张表中的数据依次取出分别与另一张表中的
--每条数据挨个组合，最后记录数量为两张表记录数的乘积

SELECT * FROM student CROSS JOIN major

--本例student和major都为7条记录，所以结果为7*7=49条记录
```

![img](https://pic1.zhimg.com/v2-dd567fe9dcef9e2a77cb14cd6054c329_b.webp)





### SQL 执行过程

<img src="https://raw.githubusercontent.com/whn961227/images/master/data/20200805092702.png" style="zoom: 33%;" />

1. 客户端发送一条查询给服务器
2. 服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段
3. 服务器进行 SQL 解析、预处理，再由优化器生成对应的执行计划
4. MySql 根据优化器生成的执行计划，再调用存储引擎的 API 来执行查询
5. 将结果返回给客户端

#### 连接

SQL 客户端与服务器建立连接，该请求被发送到连接管理器，连接成功后会验证权限等，这过程其实就是一个 TCP 连接的过程。

验证ok后，我们就连上了这个MySQL服务了，但是这个时候我们处于空闲状态。

> 注意：MySql 服务器与客户端之间的通信是 **半双工** 的

> **怎么查看空闲连接列表？**

**show processlist**，下图就是我在自己的数据库表执行命令的结果，其中的 Command 列显示为 **Sleep** 的这一行，就表示现在系统里面有一个空闲连接。

![img](https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1FpwRDhU2sroFJqmyXeCW1PAQfSuSMmRLVlnmYY5ZlpKVDPjawBTEqbVbTKK0hUYXiaoJLLKfX6DFx2A/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

这里需要注意的是，我们数据库的客户端太久没响应，连接器就会自动断开了，这个时间参数是 **wait_timeout** 控制住的，默认时长为 8 小时。

断开后重连的时候会报错，如果你想再继续操作，你就需要重连了。

> **那除了重新链接，还有别的方式么？**因为建立链接还是比较麻烦的。

使用**长连接**。

但是这里有个缺点，使用长连接之后，**内存会飙得很快**，我们知道 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。

只有在链接断开的时候才能得到释放，那如果一直使用长连接，那就会**导致 OOM（Out Of Memory）**，会导致 MySQL 重启，在 JVM 里面就会导致频繁的 Full GC。

> **怎么解决？**

执行比较大的一个查询后，执行 **mysql_reset_connection** 可以**重新初始化连接资源**。这个过程不需要重连，但是会初始化连接的状态。

#### 查询缓存

MySql 查询缓存保存**查询返回的完整结构**。当查询命中该缓存时，MySql 会立刻返回结果，跳过了解析、优化和执行阶段。

**缓存的失效很容易**，**只要对表有任何的更新**，**这个表的所有查询缓存就会全部被清空**，就会出现缓存还没使用，就直接被清空了，或者积累了很多缓存准备用来着，但是一个更新打回原形。

这就**导致查询的命中率低**的可怕，只有那种**只查询不更新的表适用缓存**，但是这s样的表往往很少存在，一般都是什么配置表之类的。

> 查询的时候不想用缓存一般都是怎么操作的，或者是用缓存又怎么操作？

可以显示调用，把 **query_cache_type** 设置成为 DEMAND，这样 SQL 默认不使用缓存，想用缓存就用 SQL_CACHE。

缓存在 MySQL 8.0 之后就**取消**了

#### 解析和预处理

**解析器**通过关键字将 SQL 语句进行**解析**，并**生成对应的解析树**。MySql 解析器将**使用 MySql 语法规则验证**和**解析查询**。

**预处理器**则**根据一些 MySql 规则进行进一步检查解析树是否合法**，例如检查数据表和数据列是否存在，还会解析名字和别名。看看它们是否有歧义

#### 查询优化器

**查询优化器**会**将解析树转换成执行计划**。一条查询可以有多种执行方法，最后都是返回相同结果，**优化器的作用就是找到其中最好的执行计划。**

因为我们建立表可能会建立很多索引，优化有一步就是要确认使用哪个索引，比如使用你的主键索引，联合索引还是什么索引更好。还有就是对执行顺序进行优化，条件那么多，先查哪个表，还是先关联，会出现很多方案，最后由优化器决定选用哪种方案。

生成执行计划的过程会消耗较多的时间，特别是存在许多可选的执行计划时

如果在一条 SQL 语句执行的过程中将该语句对应的**最终执行计划进行缓存**，当相似的语句再次被输入服务器时，就可以直接使用已缓存的执行计划，从而跳过 SQL 语句生成执行计划的整个过程，进而可以提高语句的执行速度

<img src="https://raw.githubusercontent.com/whn961227/images/master/data/20200805102651.png" style="zoom:25%;" />

MySql 使用**基于成本的查询优化器**。它会尝试预测一个查询使用某种执行计划时的成本，并选择其中成本最少的一个

#### 查询执行引擎

在解析和优化阶段，MySql 将生成查询对应的执行计划，MySql 的查询执行引擎根据这个执行计划来完成整个查询。这里执行计划是一个数据结构，而不是和其他的关系型数据库那样生成对应的字节码

#### 返回结果给客户端

如果查询可以被缓存，那么 MySql 在这个阶段会**将结果存放到查询缓存**中

MySql 将结果集返回给客户端是一个增量、逐步返回的过程。在查询生成第一条结果时，MySql 就可以开始向客户端逐步返回结果集了

### 索引

#### 分类

1. 按**存储结构**划分：BTree索引（B-Tree或B+Tree索引），Hash索引，full-index全文索引，R-Tree索引。
2. 按**应用层次**划分：普通索引，唯一索引，复合索引。
3. 根据